---
title: "An investegation into the profitability of Chicago taxis"
output: 
  html_document:
    code_folding: hide
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(tidyverse, pacman, ggmap, janitor, sf, mapview, leaflet, rgdal, RColorBrewer, lubridate)

#Register API key to google
register_google(key="AIzaSyBT6yzDKV_DGcFGK9E-cXu0zNUD4WTJOZA")

load("../data/chicago_maps_workspace.RData")

```



```{r Prepare Chicago map, include=FALSE, warning=FALSE, echo=FALSE, eval=FALSE}

#Get location of chicago
chicago <- geocode("Chicago, IL")

#Make leaflet map with chicago center
chicago_leaflet <- leaflet() %>% 
  setView(lng=chicago$lon, lat=chicago$lat, zoom=10) %>%
  addProviderTiles(providers$CartoDB.Positron)

#Save chicago areas to use for plotting
areas <- st_read("../data/chicago_community_areas/chicago_community_areas.shp", as_tibble=T, quiet=T) %>%
  clean_names() %>%
  select(area_numbe, community, geometry) %>%
  mutate(geometry = st_geometry(geometry),
         area_numbe = as.factor(area_numbe)) %>% #if this stops working extract it to own variable 
  rename(pickup_community_area = area_numbe,
         community_name = community)

```

```{r Preapare dataset for trip total map, include=FALSE, warning=FALSE, echo=FALSE, eval=FALSE}
trip_total_in_area <- taxi_trips %>%
  select(pickup_community_area, trip_total) %>%
  mutate(pickup_community_area = as.factor(pickup_community_area),
         trip_total = (as.numeric(pickup_community_area))) %>%
  group_by(pickup_community_area) %>%
  summarise(trip_total = sum(trip_total)) 

areas_trip_total <- areas %>%
  inner_join(trip_total_in_area, by="pickup_community_area") 

#Trying to color each area by trip_total
revenue_pal <- colorBin("Blues",bins=4, domain =log10(areas_trip_total$trip_total), )

#Generate html labels
label_trip_total <- 
  sprintf("<strong>%s</strong><br/>$ %s",
          areas_trip_total$community_name, prettyNum(areas_trip_total$trip_total,
                                                     big.mark=",")) %>% 
  lapply(htmltools::HTML)

```

To visualize the and highlight the differences between each area we have used interactive maps provided by the leaflet library. We used this dataset (https://data.cityofchicago.org/Facilities-Geographic-Boundaries/Boundaries-Community-Areas-current-/cauq-8yn6) provided by Chicago Data Portal to visualize the borders between community areas. The differences are highlighted by attributing a color to each area, which indicates the size of the difference relative to the other areas. Our goal was to get a clear understanding of how area and time of the day affects revenue in each area, and being able to communicate these findings as clear as possible. 

As a basis for this analysis we have plotted a map centered around Chicago. This was done by using the Leaflet library to extract a map over Chicago through Google’s map API. Thereafter we extracted pickup_community_area, community_name and geometry from the dataset of community borders. pickup_community_area is a discrete variable uniquely identifying each area and community_name is a string variable which contains its corresponding name. geometry is a Polygon(?) data type which essentially is a list of coordinates representing the borders of each area. 


We will first look into how total revenue is distributed among the areas. The relevant variables we will use are pickup_community_area and trip_total. pickup_community_area is identical to its corresponding variable in the area dataset. trip_total is a continuous numeric variable (?) representing the entire cost of the taxi trip for the passenger. We summarized over all trip_total for each area, and colored each area by the result. 
Since there are great differences in revenue between the areas we made the bins on a logarithmic scale. Because revenue between areas often vary by several orders of magnitude, the logarithmic scale gives a meaningful overview without concealing important information. 


```{r Plot trip total map, echo=TRUE}
#Make the map
chicago_leaflet %>%
  addPolygons(data=areas_trip_total,
              fillColor=~revenue_pal(log10(areas_trip_total$trip_total)),
              color="lightgrey",
              weight=2,
              fillOpacity=0.8,
              highlightOptions = highlightOptions(
                weight=3,
                opacity=2,
                color="azure1",
                bringToFront=TRUE),
              label=label_trip_total,
              labelOptions=labelOptions(
                style = list("font-weight" = "normal", padding = "3px 8px"),
                textsize = "15px",
                direction = "auto")) %>%
  
  addLegend("bottomright",
            pal = revenue_pal,
            values = log10(areas_trip_total$trip_total),
            title = "Trip total (in USD)",
            opacity = 0.8,
            labFormat = leaflet::labelFormat(
              transform = function(x) 10^(x)))
```

From the map it is clear that a few areas generate a disproportionate amount of the revenue. Does this imply that these are the most desired areas for each driver to be in? Not necesarrily. For each area there are several factors which vary; population, movement, amounts of taxis, etc. This means that although an area generates the most money overall, it’s not necessarily the same area which will earn the individual taxi driver the most money. 

```{r Prepare dataset for waiting time and hourly salary, include=FALSE, warning=FALSE, echo=FALSE, eval=FALSE}

pickup_dropoff_times <- taxi_trips %>%
  select(taxi_id, trip_end_timestamp, trip_start_timestamp, 
         pickup_community_area, dropoff_community_area,
         trip_total, trip_seconds) %>% #for in hourly_rate estimator
  mutate(trip_end_timestamp = as.double(mdy_hms(trip_end_timestamp)),
         pickup_community_area = as.factor(pickup_community_area),
         dropoff_community_area = as.factor(dropoff_community_area),
         trip_start_timestamp = as.double(mdy_hms(trip_start_timestamp)),
         trip_total = as.numeric(trip_total),
         trip_seconds = as.numeric(trip_seconds)) %>%
  drop_na()

dropoff_times <- pickup_dropoff_times %>% 
  select(taxi_id, trip_end_timestamp, dropoff_community_area) %>%
  group_by(taxi_id) %>%
  arrange(trip_end_timestamp, .by_group=TRUE) %>%
  filter(row_number() != n()) 
  

pickup_times <- pickup_dropoff_times %>%
  select(taxi_id, trip_start_timestamp, pickup_community_area,
         trip_total, trip_seconds) %>% 
  group_by(taxi_id) %>%
  arrange(trip_start_timestamp, .by_group=TRUE) %>%
  filter(row_number() != 1) 
  
  
#Dataset used as basis for plotting bost avg time to pickup in each area and
#our expected hourly rate
dropoff_to_pickup <- pickup_times %>%
  add_column(trip_end_timestamp = dropoff_times$trip_end_timestamp, .after=1) %>%
  add_column(dropoff_community_area = dropoff_times$dropoff_community_area, .after=5)

```

```{r Prepare waiting time plot, include=FALSE, warning=FALSE, echo=FALSE, eval=FALSE}

time_to_pickup <- dropoff_to_pickup %>%
  mutate(time_between = (trip_start_timestamp - trip_end_timestamp)/60) %>%
  filter(pickup_community_area == dropoff_community_area) %>%
  select(pickup_community_area, time_between) %>% 
  group_by(pickup_community_area) %>%
  filter(time_between < 300) %>% 
  summarise(avg_pickup_time = mean(time_between, na.rm=TRUE))
  
areas_pickup_time <- areas %>%
  inner_join(time_to_pickup, by="pickup_community_area") %>%
  mutate(avg_pickup_time=as.integer(avg_pickup_time))

time_pal <- colorBin("OrRd", domain=areas_pickup_time$avg_pickup_time, 
                     bins=c(0, 6, 12, 18, 24, 30), 
                     reverse=TRUE, na.color='floralwhite')

#Generate html labels
label_avg_pickup_time <- sprintf(
  "<strong>%s</strong><br/>Average time from dropoff to new pickup:<br/>%g minutes",
  areas_pickup_time$community_name, areas_pickup_time$avg_pickup_time
) %>% lapply(htmltools::HTML)

#Labels for the legend
waiting_time_labels<-c('< 6 minutes', '6 - 12 minutes', '12 - 18 minutes', '18 - 24 minutes', 
         '> 24 minutes')
```

To not get muddled by these hidden factors in total revenue, we can take a different approach. We will look at the average  time from a taxi drops someone off in an area, until the same taxi picks someone else up in the same area. We will only consider pickups and drop-offs which happen in the same area. This is because taxis which travel from one area to another between drop-off and pickup will inflate the average time. This could potentially lead to the central areas getting higher averages, as taxi drivers are inclined to travel back to the city center after a drop-off. 

We extract taxi_id, trip_start_timestamp, trip_end_timestamp, pickup_community_area and dropoff_community_area from our dataset. taxi_id is an unique string identifier for each taxi and pickup_community_area and dropoff_community_area are identical to the previous description of pickup_community_area. trip_start_timestamp and trip_end_timestamp are date strings one the format “MM/DD/YYYY hh:mm:ss”, which indicates time of trip start and end.  We should note that the timestamps has been rounded to nearest 15 minute for privacy purposes. Therefore the result will not be 100% accurate, but it will give a good estimate of the true time to pickup. The results can be seen below.


```{r Plot waiting time map, include=TRUE, warning=FALSE, echo=TRUE}

chicago_leaflet %>%
  addPolygons(data=areas_pickup_time,
              fillColor=~time_pal(areas_pickup_time$avg_pickup_time),
              color="lightgrey",
              weight=2,
              fillOpacity=0.8,
              highlightOptions = highlightOptions(
                weight=3,
                opacity=2,
                color="azure1",
                bringToFront=TRUE),
              label=label_avg_pickup_time,
              labelOptions=labelOptions(
                style = list("font-weight" = "normal", padding = "3px 8px"),
                textsize = "15px",
                direction = "auto")) %>%
  
  addLegend("bottomright",
            pal = time_pal,
            labFormat = function(type, cuts, p) {  # To get custom labels
              paste0(waiting_time_labels)
            },
            values = areas_pickup_time$avg_pickup_time,
            title = "Average time between pickup and dropoff",
            opacity = 0.8)

```

When considering optimal areas for each individual taxi driver, the plots paint a fairly different picture. The revenue plot and activity plot both point towards the areas around Loop as generating the most money. This is considered the center of downtown. In addition O’Hare, the airport of Chicago, is one of the top earners. When plotting the waiting time, however, it is clear that these taxis in these areas also are more prone to waiting time – with O’Hare averaging 95 minutes in waiting time. 

```{r Prepare dataset for hourly rate, include=FALSE, warning=FALSE, echo=FALSE, eval=FALSE}

avg_hourly_rate <- dropoff_to_pickup %>%
  mutate(waiting_time = (trip_start_timestamp - trip_end_timestamp)/60) %>%
  filter(pickup_community_area == dropoff_community_area) %>%
  filter(waiting_time < 300) %>% #remove outliers which indicate end of workday
  group_by(pickup_community_area) %>%
  summarise(avg_trip_total = mean(trip_total), 
            avg_trip_seconds = mean(trip_seconds),
            waiting_time = mean(waiting_time)) 

avg_hourly_rate <- avg_hourly_rate %>%
  mutate(hourly_rate = avg_trip_total / (waiting_time/60 + avg_trip_seconds/3600)) %>%
  #select(taxi_id, waiting_time, pickup_community_area, avg_trip_total, avg_trip_seconds) %>%
  select(pickup_community_area, hourly_rate) 
  
areas_hourly_rate <- areas %>%
  inner_join(avg_hourly_rate, by="pickup_community_area") %>%
  mutate(hourly_rate=as.integer(hourly_rate)) %>%
  print()


hourly_pal <- colorBin("OrRd", domain=areas_hourly_rate$hourly_rate, 
                       bins = c(0, 20, 25, 30, 35, 40, 100), na.color='tomato4')

#Generate html labels
label_avg_hourly_rate <- sprintf(
  "<strong>%s</strong><br/>Average hourly rate:<br/>$ %d",
  areas_hourly_rate$community_name, areas_hourly_rate$hourly_rate
) %>% lapply(htmltools::HTML)

hourly_labels <- c('< 20 $', '20 - 25 $', '25 - 30 $', '30 - 25 $', '35 - 40 $', '> 40 $')

```

None of these plots paint the whole picture on its own. Although the waiting time at O’Hare airport is large, a trip from the airport to the city center would generate much more revenue  than a trip from Loop to West Town. To take these differences into account, we will combine three factors which will make a measure for expected hourly salary in each area. 
Our expected salary is  made up of two main components: expected income and expected time spent: (expected income / expected time). Expected time spent will further be divided into expected waiting time and expected trip time. These estimators(maybe not call them this) are obtained by averaging over our dataset in similar fashion as done earlier. The distribution for each area is shown below: (if we bootstrap, mention it here)


```{r Plot hourly salary, include=TRUE, warning=FALSE, echo=TRUE}

chicago_leaflet %>%
  addPolygons(data=areas_hourly_rate,
              fillColor=~hourly_pal(areas_hourly_rate$hourly_rate),
              color="lightgrey",
              weight=2,
              fillOpacity=0.8,
              highlightOptions = highlightOptions(
                weight=3,
                opacity=2,
                color="azure1",
                bringToFront=TRUE),
              label=label_avg_hourly_rate,
              labelOptions=labelOptions(
                style = list("font-weight" = "normal", padding = "3px 8px"),
                textsize = "15px",
                direction = "auto")) %>%
  
  addLegend("bottomright",
            pal = hourly_pal,
            labFormat = function(type, cuts, p) {  # To get custom labels
              paste0(hourly_labels)
            },
            values = areas_hourly_rate$hourly_rate,
            title = "Average hourly rate",
            opacity = 0.8)

```

This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately. 

To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).

## Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r eruptions, echo=FALSE}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(10, 20, 35, 50), selected = 20),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 0.2, max = 2, value = 1, step = 0.2)
)

renderPlot({
  hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "Duration (minutes)", main = "Geyser eruption duration")
  
  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

## Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r tabsets, echo=FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package = "shiny"),
  options = list(
    width = "100%", height = 550
  )
)
```

Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.



